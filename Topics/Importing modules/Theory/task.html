<div class="step-text">
<p>There are different ways to interact with code. In this topic, we'll learn what they are and when an option is the most appropriate. However, most importantly, we'll find out how to save our code into a file for further use or editing. As you probably have already guessed, that applies to any code, which means you can also use someone else's code, and this last part is a pretty big deal you'll quickly appreciate as a developer.</p>
<h5 id="module-basics">Module basics</h5>
<p>While working on simple examples, you probably type your code directly into the <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, an interpreter is a layer of software logic that executes your program, going through the code line by line. | It is a part of the standard Python installation package. The interpreter translates the source code into a set of instructions that can be executed directly by your computer's processor. This is in contrast to compiled languages, where a special software called a compiler is used to translate the source code into machine code, which is a set of instructions executed directly by the processor.">interpreter</a>. But every time you exit the interpreter and start it again, you lose all the definitions you made before. So as you start writing larger programs, it makes sense to prepare your code in advance using a text editor and then run it with the interpreter. A file containing a list of operations that will be read and interpreted further on is called <strong>script</strong>.</p>
<p>You may also want to write some functions and then use them in other programs or even reuse code someone else wrote before. One way is just to copy the code into your program, but it soon leads to code that is badly structured and hard to read. Luckily, there is another way in Python to organize and reuse code called <strong>modules</strong>.</p>
<p>A module is simply a file that contains Python statements and definitions. It usually has a <strong>.py</strong> extension. What really makes the module system powerful is the ability to <strong>load</strong> or <strong>import</strong> one module from another.</p>
<h5 id="module-loading">Module loading</h5>
<p>To load a module, just use an <strong>import </strong>statement. In its basic form, it has the following syntax: <code class="language-python">import module</code>.</p>
<pre><code class="language-python">import super_module

# calling a function defined in super_module
super_module.super_function()  

# accessing a variable defined in super_module
print(super_module.super_variable)  </code></pre>
<p><code class="language-python">super_module</code> is the name of the module you want to import. For example, a file called super_module.py has a name super_module. In order to be available for import, super_module.py should be located in the same directory as the file you are trying to import <code class="language-python">super_module</code> to. At first, Python importing system looks for a module in the current directory, then it checks the <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a built-in module is a set of functions, classes, or variables that are made available to the Python interpreter by the Python core team. | These modules are pre-installed and can be used without any additional installation steps. They provide various functionalities such as working with Python data structures, file and directory operations, serialization, and deserialization, etc. For example, the `pickle` module is a built-in module that can work with various Python data structures. It has two functions `pickle.dump()` and `pickle.load()` for serialization and deserialization respectively. Another example is the `os` module, which provides functions for interacting with the operating system, such as getting the current working directory, changing the current working directory, etc. To use a built-in module, you can import it using the standard import statement, such as `import pickle` or `import os`.">built-in modules</a>, and if nothing is found an error will be raised. After importing, the module becomes available under its name and you can access functions and variables defined in it using the <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, dot notation, also known as dot syntax, is a way to access attributes or methods of an object. | It is denoted by the . (dot) symbol followed by the attribute or method name. For instance, if you have an object named obj, you can access its attribute attr using the syntax obj.attr. This notation is commonly used in Python to access functions and variables defined in a module. When using dot notation, it is generally a good practice to import only the required functions or variables from a module instead of the entire module.">dot notation</a> (<code class="language-python">super_module.super_function()</code>).</p>
<p>It's also common to only import the required functions or variables from a module but not the module itself. You can do this by using <code class="language-python">from</code> in the import statement.</p>
<pre><code class="language-python">from super_module import super_function

# super_function is now available directly at the current module
super_function()  

super_module.super_function()  
# note that in this case name super_module is not imported, 
# so this line leads to an error</code></pre>
<p>A good practice is to load a single module in a single line and put all your imports at the top of the file because it increases readability.</p>
<pre><code class="language-python">import module1
import module2
import module3

# the rest of module code goes here</code></pre>
<p>A special form of import statement allows you to load all the names defined in a module. It is called <strong><em><a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a wildcard import is a form of import statement that allows you to load all the names defined in a module into the current namespace. | It has the syntax from module_name import \*. However, it is generally discouraged to use wildcard imports in your code. This is because it can lead to unexpected behavior since you may not be aware of all the names that are being imported into the current namespace. It can also make your code less readable and make it harder for both humans and automated tools to understand which names are present in the namespace.">wildcard import</a></em></strong><em> </em>and has the syntax <code class="language-python">from module import *</code>. You should generally avoid this in your code. It can cause unexpected behavior because you don't know what names exactly are imported into the current <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a namespace is a container for a set of identifiers (names of variables, functions, classes, etc.) | that are defined in a module or a function. It helps to avoid naming conflicts and allows you to access identifiers using the dot notation. When you import a module, its namespace is added to the current namespace, and you can access its identifiers directly. However, if you want to avoid cluttering the current namespace, you can use the `from ... import ...` statement to import only specific identifiers from a module. Additionally, Python has a concept of scope, which determines the visibility and lifetime of identifiers.">namespace</a>. Besides, these names may shadow some of the existing ones without your knowledge. It's better to make it explicit and specify what you're importing.</p>
<p>In case you have to use several import statements, pay attention to their order:</p>
<ol><li><p><a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a standard library is a collection of built-in modules that come pre-installed with the Python programming language. | These modules provide access to various useful functions and data structures, such as mathematical functions, string operations, and random number generation. The standard library is available on every system that has Python installed, making it a convenient and powerful resource for developers. Additionally, many widely-used algorithms can be found in the Python standard library or in external packages, providing ready-to-use functions for various problems.">standard library</a> imports, i.e. from the Standard Python library</p></li><li><p>third party dependency imports, i.e. something installed additionally</p></li><li><p>local application imports, i.e. files that belong to the current application</p></li></ol>
<p>Having your imports grouped, you may put a blank line between import sections. Also, some guidelines, including ours, recommend sorting imports alphabetically.</p>
<h5 id="built-in-modules">Built-in modules</h5>
<p>Python comes with a great standard library. It contains a lot of built-in modules that provide useful functions and data structures. Another advantage is that the standard library is available on every system that has Python installed. <a href="https://docs.python.org/3/py-modindex.html" rel="noopener noreferrer nofollow" target="_blank">Here</a> you can find the official library reference.</p>
<p>Python has a math module that provides access to <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a mathematical function is a type of function that adheres to the principles of mathematical functions in the realm of programming. | It takes an input, performs a specific calculation without any intermediate manipulations, and returns a resulting value. An example of a mathematical function is the sine function, where you provide it with a value of x, and it returns the sine of that value. Regardless of how many times you input the same value, the function will always return the same result. Python, although not a purely functional language, supports functional programming through features like lambda functions and higher-order functions.">mathematical functions</a>.</p>
<pre><code class="language-python">import math

print(math.factorial(5))  # prints the value of 5!

print(math.log(10))  # prints the natural logarithm of 10

print(math.pi)  # math also contains several constants
print(math.e)</code></pre>
<p>The string module contains common string operations and <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a constant is a type of variable that, once assigned a value, cannot be reassigned. | However, Python does not have built-in support for constants, and variable names are not enforced to be constant. Instead, programmers use naming conventions to indicate that a variable should be treated as a constant. In the context of the provided text, the discussion revolves around two specific constants, `inf` and `-inf`, which represent positive and negative infinity, respectively. These constants are part of the floating-point arithmetic system and follow the same rules as other floating-point numbers. They can be used in arithmetic operations, and their use can optimize algorithms and find the lowest and highest values in a list of values.">constants</a>.</p>
<pre><code class="language-python">from string import digits

print(digits)  # prints all the digit symbols</code></pre>
<p>The <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, the `random` module is a built-in module that provides functions to generate pseudo-random numbers. | It uses an algorithm with a starting point called a seed to generate these numbers. The seed allows you to save the current state, making it easy to reproduce the same set of numbers on multiple code executions. However, since the results are generated using an algorithm, they are not truly random and the module should be called a pseudo-random module. This module can be used to quickly generate a large number of examples for testing or other purposes.">random module</a> provides functions that let you make a random choice.</p>
<pre><code class="language-python">from random import choice

# print a random item from the list
print(choice(['red', 'green', 'yellow']))  </code></pre>
<h5 id="summary">Summary</h5>
<p>Thus, in this topic, we've learned what scripts and modules are, why they're useful, how to import modules or particular things from them and whether or not we need to use a module's name to access them. We've also discussed external modules and those that come with a standard Python library. This basic skill will definitely give you a lot of opportunities in the future, so don't be shy to try <a class="theory-lookup not-relevant" href="/learn/step/6019" rel="noopener noreferrer nofollow" target="_blank" title="In Python, module loading is the process of making a module (a file containing Python definitions and statements) available in the current Python environment, so its functions, classes, and variables can be used in the current script or interactive session. | This allows for code reusability and organization, especially in larger projects. Module loading can be done using the import statement, followed by the name of the module. For example, if you have a module named hello.py, you can load it in the interpreter by typing import hello. You can also use a wildcard import to import all public objects from a module, by using the syntax from module_name import \*.">module loading</a> on your own!</p>
</div>