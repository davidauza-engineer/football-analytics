<div class="step-text">
<p>Even though <a class="theory-lookup not-relevant" href="/learn/step/5891" rel="noopener noreferrer nofollow" target="_blank" title="In Python, invoking refers to the process of starting or executing a function, method, or coroutine. | It can be done in two ways: by using an operator or by calling a method. For instance, when you perform a union on two sets, you get a new set that comprises all the elements of the initial sets. This can be done using the `union()` method or the `` operator. Similarly, coroutines become tasks when they are passed to the `asyncio.create_task()` function, which schedules them to run. In this context, a future represents a computation that hasn't necessarily been completed yet. When a future object is awaited, the coroutine will wait until the future is resolved somewhere else.">invoking</a> functions in Python is not about casting a spell or the like, it does sometimes work wonders. Let's start with the concept. A <strong>function</strong> is a structured fragment of code we may want to use in more than one place and more than one time. What's more, functions allow us to read both our code and that of someone else way better. Haven't they become your favorite yet?</p><p>Here is a simple function call:</p><p><code class="language-python">multiply(1, 7)</code></p><p>Here <code class="language-python">multiply</code> is the name of the function, and numbers in parentheses <code class="language-python">(1, 7)</code> are its <strong>arguments</strong>. What is an argument? Well, it's just a value, that will be used inside the function body. Let's go deeper into it!</p><h5 id="invoking-print">Invoking print()</h5><p>To <strong>call</strong>, or <strong>invoke</strong>, <strong>a function</strong> in your program, simply write its name and add parentheses after it. That's all it takes! Fun fact: if you've ever typed an expression like this <code class="language-python">print("Hello, world!")</code>, you already know a little about functions. In this tiny example, however, we see the message "Hello, world!" in parentheses after the name of the <code class="language-python">print</code> function. What does it mean? This string is just an argument. And more often than not, functions do have arguments. As for the <code class="language-python">print</code> function, we may as well use it with no argument at all or even with multiple arguments:</p><pre><code class="language-python">print("Hello, world!")
print()
print("Bye,", "then!")</code></pre><p>And here is the output:</p><pre><code class="language-python">Hello, world!

Bye, then!</code></pre><p>So, the first call prints<strong> </strong>one string, and the second call of <code class="language-python">print</code> without arguments prints, an empty line, and the last call outputs our two messages as one expression. Are you surprised by these results? Then you may learn how the <code class="language-python">print</code> function works in more detail from its <a href="https://docs.python.org/3/library/functions.html#print" rel="noopener noreferrer nofollow" target="_blank">documentation</a>. The Python documentation contains all sorts of information about the function of your interest, for example, which arguments it expects.</p><h5 id="built-in-functions">Built-in functions</h5><p>Functions can make life easier, provided one is aware of their existence. Many algorithms are already written, so there is no need for reinvention, except perhaps for educational purposes. The Python <a class="theory-lookup not-relevant" href="/learn/step/5891" rel="noopener noreferrer nofollow" target="_blank" title="In Python, an interpreter is a layer of software logic that executes your program, going through the code line by line. | It is a part of the standard Python installation package. The interpreter translates the source code into a set of instructions that can be executed directly by your computer's processor. This is in contrast to compiled languages, where a special software called a compiler is used to translate the source code into machine code, which is a set of instructions executed directly by the processor.">interpreter</a> has several functions and types <strong>built into</strong> it, so they are always available. Currently, the number of <a class="theory-lookup not-relevant" href="/learn/step/5891" rel="noopener noreferrer nofollow" target="_blank" title="In Python, built-in functions are pre-defined functions that are readily available for use in your programs. | They are always available and do not require any declaration or import. Examples include the `len()` function, which returns the length of an object, and the `max()` function, which returns the largest item in an iterable. These functions can be used directly on iterable objects such as strings and lists. It is important to note that built-in functions can either perform an action without returning anything or return a specific result.">built-in functions</a> amounts to 71 (in the <strong>Python 3.13 </strong>version). Some of them are used to convert the <a class="theory-lookup not-relevant" href="/learn/step/5891" rel="noopener noreferrer nofollow" target="_blank" title="In Python, an object type is a category of data objects that describes how they are stored in memory, which operations can be applied to them, and how those operations are executed. | This concept is similar to real-world attributes shared among specific objects, such as the dog species. For instance, all dogs have the type dog, but each dog is an individual object. In Python, every value is stored in objects. You can think of an object as a box that contains information about a value and stores additional data, such as its identity. When you assign a value to a variable, Python creates a new object, places the value inside the new object, and then creates a reference from the variable name to the object. Examples of data objects in Python include lists, tuples, sets, and dictionaries. Understanding how different types of objects work in Python will help you understand more complex topics and the structure of the language."><strong>object type</strong></a>, for example, <code class="language-python">str()</code> returns a string, <code class="language-python">int()</code> returns an integer, and <code class="language-python">float()</code> returns a floating-point number. Others deal with <strong>numbers</strong>: you can <code class="language-python">round()</code> them and <code class="language-python">sum()</code> them, find the minimum <code class="language-python">min()</code> or the maximum <code class="language-python">max()</code>. Still, others give us information about the object: its <code class="language-python">type()</code> or length <code class="language-python">len()</code>. Let's consider them in action!</p><p>In the following example, <code class="language-python">len()</code> counts the number of characters in the string (the same goes for any <a class="theory-lookup not-relevant" href="/learn/step/5891" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a sequence is a type of data structure that can store multiple items in a particular order. | It includes lists, tuples, and strings. Sequences are characterized by their ability to be indexed, sliced, and iterated over. Indexing allows you to access individual elements of the sequence by their position, slicing allows you to extract a subset of the sequence, and iteration allows you to loop through the elements of the sequence. Additionally, sequences are immutable, meaning that once they are created, their elements cannot be changed."><strong>sequence</strong></a>, i.e. list, tuple, range, byte sequences, byte arrays).</p><pre><code class="language-python">number = "111"

# finding the length of an object
print(len(number))  # 3</code></pre><p>Then we declare the variables <code class="language-python">integer</code> and <code class="language-python">float_number</code>, convert our string to corresponding types, and write their sum into <code class="language-python">my_sum</code>. By the way, the <code class="language-python">sum()</code> function deals with iterable objects, that's why we use double parentheses.</p><pre><code class="language-python"># converting types
integer = int(number)  # 111
float_number = float(number)  # 111.0

# adding numbers
my_sum = sum((integer, float_number))</code></pre><p>The result is a floating-point number, which becomes clear after printing <code class="language-python">my_sum</code>.</p><pre><code class="language-python">print(my_sum)  # 222.0
print(round(my_sum))  # 222</code></pre><p>Furthermore, you can see how to find the minimum and maximum values: in this example, the smallest number equals 3 and the largest number 8.4 (the sum of 3 and 5.4) belongs to floats.</p><pre><code class="language-python"># finding the minimum and the maximum
integer = 3
float_number = 5.4
my_sum = sum((integer, float_number))

print(min(integer, float_number))  # 3
print(type(max(integer, float_number, my_sum)))  # &lt;class 'float'&gt;</code></pre><p>There is far more to explore, but let's sum it up.</p><h5 id="conclusion">Conclusion</h5><p>The beauty of functions is that we can use them without clear insight into their inner structure, and how they manage to perform what we need. If you want to put a function to good use, make sure to check its documentation or try invoking the special <code class="language-python">help()</code> function with the name of the function in question wrapped in parentheses. It saves the day when the function behaves unexpectedly.</p><pre><code class="language-python">help(len)

# Help on built-in function len in module builtins:
#
# len(obj, /)
#    Return the number of items in a container.</code></pre><p>Let's make a summary:</p><ul><li><p>functions are meant to be reusable. You can apply them multiple times with different arguments,</p></li><li><p>to call a function write its name followed by parentheses and place the arguments within,</p></li><li><p>normally, a function has documentation, which sometimes might be of huge help.</p></li></ul>
</div>